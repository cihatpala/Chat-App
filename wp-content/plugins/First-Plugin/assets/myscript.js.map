{"version":3,"file":"myscript.js","sources":["myscript.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\r\n * @license\r\n * Copyright (C) 2006 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview\r\n * some functions for browser-side pretty printing of code contained in html.\r\n *\r\n * <p>\r\n * For a fairly comprehensive set of languages see the\r\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\r\n * file that came with this source.  At a minimum, the lexer should work on a\r\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\r\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\r\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\r\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\r\n * <p>\r\n * Usage: <ol>\r\n * <li> include this source file in an html page via\r\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\r\n * <li> define style rules.  See the example page for examples.\r\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\r\n *    {@code class=prettyprint.}\r\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\r\n *    printer needs to do more substantial DOM manipulations to support that, so\r\n *    some css styles may not be preserved.\r\n * </ol>\r\n * That's it.  I wanted to keep the API as simple as possible, so there's no\r\n * need to specify which language the code is in, but if you wish, you can add\r\n * another class to the {@code <pre>} or {@code <code>} element to specify the\r\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\r\n * starts with \"lang-\" followed by a file extension, specifies the file type.\r\n * See the \"lang-*.js\" files in this directory for code that implements\r\n * per-language file handlers.\r\n * <p>\r\n * Change log:<br>\r\n * cbeust, 2006/08/22\r\n * <blockquote>\r\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\r\n * </blockquote>\r\n * @requires console\r\n */\r\n\r\n// JSLint declarations\r\n/*global console, document, navigator, setTimeout, window, define */\r\n\r\n\r\n/**\r\n* @typedef {!Array.<number|string>}\r\n* Alternating indices and the decorations that should be inserted there.\r\n* The indices are monotonically increasing.\r\n*/\r\nvar DecorationsT;\r\n\r\n/**\r\n* @typedef {!{\r\n*   sourceNode: !Element,\r\n*   pre: !(number|boolean),\r\n*   langExtension: ?string,\r\n*   numberLines: ?(number|boolean),\r\n*   sourceCode: ?string,\r\n*   spans: ?(Array.<number|Node>),\r\n*   basePos: ?number,\r\n*   decorations: ?DecorationsT\r\n* }}\r\n* <dl>\r\n*  <dt>sourceNode<dd>the element containing the source\r\n*  <dt>sourceCode<dd>source as plain text\r\n*  <dt>pre<dd>truthy if white-space in text nodes\r\n*     should be considered significant.\r\n*  <dt>spans<dd> alternating span start indices into source\r\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\r\n*     span.\r\n*  <dt>decorations<dd>an array of style classes preceded\r\n*     by the position at which they start in job.sourceCode in order\r\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\r\n*     source.\r\n* </dl>\r\n*/\r\nvar JobT;\r\n\r\n/**\r\n* @typedef {!{\r\n*   sourceCode: string,\r\n*   spans: !(Array.<number|Node>)\r\n* }}\r\n* <dl>\r\n*  <dt>sourceCode<dd>source as plain text\r\n*  <dt>spans<dd> alternating span start indices into source\r\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\r\n*     span.\r\n* </dl>\r\n*/\r\nvar SourceSpansT;\r\n\r\n/** @define {boolean} */\r\nvar IN_GLOBAL_SCOPE = false;\r\n\r\nvar HACK_TO_FIX_JS_INCLUDE_PL;\r\n\r\n/**\r\n * {@type !{\r\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\r\n *   'registerLangHandler': function (function (JobT), Array.<string>),\r\n *   'PR_ATTRIB_NAME': string,\r\n *   'PR_ATTRIB_NAME': string,\r\n *   'PR_ATTRIB_VALUE': string,\r\n *   'PR_COMMENT': string,\r\n *   'PR_DECLARATION': string,\r\n *   'PR_KEYWORD': string,\r\n *   'PR_LITERAL': string,\r\n *   'PR_NOCODE': string,\r\n *   'PR_PLAIN': string,\r\n *   'PR_PUNCTUATION': string,\r\n *   'PR_SOURCE': string,\r\n *   'PR_STRING': string,\r\n *   'PR_TAG': string,\r\n *   'PR_TYPE': string,\r\n *   'prettyPrintOne': function (string, string, number|boolean),\r\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\r\n * }}\r\n * @const\r\n */\r\nvar PR;\r\n\r\n/**\r\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\r\n * UI events.\r\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\r\n */\r\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\r\n\r\n/**\r\n * Pretty print a chunk of code.\r\n * @param {string} sourceCodeHtml The HTML to pretty print.\r\n * @param {string} opt_langExtension The language name to use.\r\n *     Typically, a filename extension like 'cpp' or 'java'.\r\n * @param {number|boolean} opt_numberLines True to number lines,\r\n *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n * @return {string} code as html, but prettier\r\n */\r\nvar prettyPrintOne;\r\n/**\r\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n * {@code class=prettyprint} and prettify them.\r\n *\r\n * @param {Function} opt_whenDone called when prettifying is done.\r\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n *   containing all the elements to pretty print.\r\n *   Defaults to {@code document.body}.\r\n */\r\nvar prettyPrint;\r\n\r\n\r\n(function () {\r\n  var win = window;\r\n  // Keyword lists for various languages.\r\n  // We use things that coerce to strings to make them compact when minified\r\n  // and to defeat aggressive optimizers that fold large string constants.\r\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\r\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\r\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\r\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\r\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\r\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\r\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\r\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\r\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\r\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\r\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\r\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\r\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\r\n      \"throws,transient\"];\r\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\r\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\r\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\r\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\r\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\r\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\r\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\r\n      \"throw,true,try,unless,until,when,while,yes\";\r\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\r\n      \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\r\n      \"yield,Infinity,NaN\"];\r\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\r\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\r\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\r\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\r\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\r\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\r\n      \"False,True,None\"];\r\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\r\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\r\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\r\n      \"BEGIN,END\"];\r\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\r\n      \"function,in,local,set,then,until\"];\r\n  var ALL_KEYWORDS = [\r\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\r\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\r\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\r\n\r\n  // token style names.  correspond to css classes\r\n  /**\r\n   * token style for a string literal\r\n   * @const\r\n   */\r\n  var PR_STRING = 'str';\r\n  /**\r\n   * token style for a keyword\r\n   * @const\r\n   */\r\n  var PR_KEYWORD = 'kwd';\r\n  /**\r\n   * token style for a comment\r\n   * @const\r\n   */\r\n  var PR_COMMENT = 'com';\r\n  /**\r\n   * token style for a type\r\n   * @const\r\n   */\r\n  var PR_TYPE = 'typ';\r\n  /**\r\n   * token style for a literal value.  e.g. 1, null, true.\r\n   * @const\r\n   */\r\n  var PR_LITERAL = 'lit';\r\n  /**\r\n   * token style for a punctuation string.\r\n   * @const\r\n   */\r\n  var PR_PUNCTUATION = 'pun';\r\n  /**\r\n   * token style for plain text.\r\n   * @const\r\n   */\r\n  var PR_PLAIN = 'pln';\r\n\r\n  /**\r\n   * token style for an sgml tag.\r\n   * @const\r\n   */\r\n  var PR_TAG = 'tag';\r\n  /**\r\n   * token style for a markup declaration such as a DOCTYPE.\r\n   * @const\r\n   */\r\n  var PR_DECLARATION = 'dec';\r\n  /**\r\n   * token style for embedded source.\r\n   * @const\r\n   */\r\n  var PR_SOURCE = 'src';\r\n  /**\r\n   * token style for an sgml attribute name.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_NAME = 'atn';\r\n  /**\r\n   * token style for an sgml attribute value.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_VALUE = 'atv';\r\n\r\n  /**\r\n   * A class that indicates a section of markup that is not code, e.g. to allow\r\n   * embedding of line numbers within code listings.\r\n   * @const\r\n   */\r\n  var PR_NOCODE = 'nocode';\r\n\r\n  \r\n  \r\n  /**\r\n   * A set of tokens that can precede a regular expression literal in\r\n   * javascript\r\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\r\n   * has the full list, but I've removed ones that might be problematic when\r\n   * seen in languages that don't support regular expression literals.\r\n   *\r\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\r\n   * literal in a syntactically legal javascript program, and I've removed the\r\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\r\n   * as a count of inches.\r\n   *\r\n   * <p>The link above does not accurately describe EcmaScript rules since\r\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\r\n   * very well in practice.\r\n   *\r\n   * @private\r\n   * @const\r\n   */\r\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\r\n  \r\n  // CAVEAT: this does not properly handle the case where a regular\r\n  // expression immediately follows another since a regular expression may\r\n  // have flags for case-sensitivity and the like.  Having regexp tokens\r\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\r\n  // TODO: maybe style special characters inside a regexp as punctuation.\r\n\r\n  /**\r\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\r\n   * matches the union of the sets of strings matched by the input RegExp.\r\n   * Since it matches globally, if the input strings have a start-of-input\r\n   * anchor (/^.../), it is ignored for the purposes of unioning.\r\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\r\n   * @return {RegExp} a global regex.\r\n   */\r\n  function combinePrefixPatterns(regexs) {\r\n    var capturedGroupIndex = 0;\r\n  \r\n    var needToFoldCase = false;\r\n    var ignoreCase = false;\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.ignoreCase) {\r\n        ignoreCase = true;\r\n      } else if (/[a-z]/i.test(regex.source.replace(\r\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\r\n        needToFoldCase = true;\r\n        ignoreCase = false;\r\n        break;\r\n      }\r\n    }\r\n  \r\n    var escapeCharToCodeUnit = {\r\n      'b': 8,\r\n      't': 9,\r\n      'n': 0xa,\r\n      'v': 0xb,\r\n      'f': 0xc,\r\n      'r': 0xd\r\n    };\r\n  \r\n    function decodeEscape(charsetPart) {\r\n      var cc0 = charsetPart.charCodeAt(0);\r\n      if (cc0 !== 92 /* \\\\ */) {\r\n        return cc0;\r\n      }\r\n      var c1 = charsetPart.charAt(1);\r\n      cc0 = escapeCharToCodeUnit[c1];\r\n      if (cc0) {\r\n        return cc0;\r\n      } else if ('0' <= c1 && c1 <= '7') {\r\n        return parseInt(charsetPart.substring(1), 8);\r\n      } else if (c1 === 'u' || c1 === 'x') {\r\n        return parseInt(charsetPart.substring(2), 16);\r\n      } else {\r\n        return charsetPart.charCodeAt(1);\r\n      }\r\n    }\r\n  \r\n    function encodeEscape(charCode) {\r\n      if (charCode < 0x20) {\r\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\r\n      }\r\n      var ch = String.fromCharCode(charCode);\r\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\r\n          ? \"\\\\\" + ch : ch;\r\n    }\r\n  \r\n    function caseFoldCharset(charSet) {\r\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\r\n          new RegExp(\r\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\r\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\r\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\r\n              + '|\\\\\\\\[0-7]{1,2}'\r\n              + '|\\\\\\\\[\\\\s\\\\S]'\r\n              + '|-'\r\n              + '|[^-\\\\\\\\]',\r\n              'g'));\r\n      var ranges = [];\r\n      var inverse = charsetParts[0] === '^';\r\n  \r\n      var out = ['['];\r\n      if (inverse) { out.push('^'); }\r\n  \r\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\r\n        var p = charsetParts[i];\r\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\r\n          out.push(p);\r\n        } else {\r\n          var start = decodeEscape(p);\r\n          var end;\r\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\r\n            end = decodeEscape(charsetParts[i + 2]);\r\n            i += 2;\r\n          } else {\r\n            end = start;\r\n          }\r\n          ranges.push([start, end]);\r\n          // If the range might intersect letters, then expand it.\r\n          // This case handling is too simplistic.\r\n          // It does not deal with non-latin case folding.\r\n          // It works for latin source code identifiers though.\r\n          if (!(end < 65 || start > 122)) {\r\n            if (!(end < 65 || start > 90)) {\r\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\r\n            }\r\n            if (!(end < 97 || start > 122)) {\r\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\r\n      // -> [[1, 12], [14, 14], [16, 17]]\r\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\r\n      var consolidatedRanges = [];\r\n      var lastRange = [];\r\n      for (var i = 0; i < ranges.length; ++i) {\r\n        var range = ranges[i];\r\n        if (range[0] <= lastRange[1] + 1) {\r\n          lastRange[1] = Math.max(lastRange[1], range[1]);\r\n        } else {\r\n          consolidatedRanges.push(lastRange = range);\r\n        }\r\n      }\r\n  \r\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\r\n        var range = consolidatedRanges[i];\r\n        out.push(encodeEscape(range[0]));\r\n        if (range[1] > range[0]) {\r\n          if (range[1] + 1 > range[0]) { out.push('-'); }\r\n          out.push(encodeEscape(range[1]));\r\n        }\r\n      }\r\n      out.push(']');\r\n      return out.join('');\r\n    }\r\n  \r\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\r\n      // Split into character sets, escape sequences, punctuation strings\r\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\r\n      // include any of the above.\r\n      var parts = regex.source.match(\r\n          new RegExp(\r\n              '(?:'\r\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\r\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\r\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\r\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\r\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\r\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\r\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\r\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\r\n              + ')',\r\n              'g'));\r\n      var n = parts.length;\r\n  \r\n      // Maps captured group numbers to the number they will occupy in\r\n      // the output or to -1 if that has not been determined, or to\r\n      // undefined if they need not be capturing in the output.\r\n      var capturedGroups = [];\r\n  \r\n      // Walk over and identify back references to build the capturedGroups\r\n      // mapping.\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          // groups are 1-indexed, so max group index is count of '('\r\n          ++groupIndex;\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue) {\r\n            if (decimalValue <= groupIndex) {\r\n              capturedGroups[decimalValue] = -1;\r\n            } else {\r\n              // Replace with an unambiguous escape sequence so that\r\n              // an octal escape sequence does not turn into a backreference\r\n              // to a capturing group from an earlier regex.\r\n              parts[i] = encodeEscape(decimalValue);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Renumber groups and reduce capturing groups to non-capturing groups\r\n      // where possible.\r\n      for (var i = 1; i < capturedGroups.length; ++i) {\r\n        if (-1 === capturedGroups[i]) {\r\n          capturedGroups[i] = ++capturedGroupIndex;\r\n        }\r\n      }\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          ++groupIndex;\r\n          if (!capturedGroups[groupIndex]) {\r\n            parts[i] = '(?:';\r\n          }\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue && decimalValue <= groupIndex) {\r\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Remove any prefix anchors so that the output will match anywhere.\r\n      // ^^ really does mean an anchored match though.\r\n      for (var i = 0; i < n; ++i) {\r\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\r\n      }\r\n  \r\n      // Expand letters to groups to handle mixing of case-sensitive and\r\n      // case-insensitive patterns if necessary.\r\n      if (regex.ignoreCase && needToFoldCase) {\r\n        for (var i = 0; i < n; ++i) {\r\n          var p = parts[i];\r\n          var ch0 = p.charAt(0);\r\n          if (p.length >= 2 && ch0 === '[') {\r\n            parts[i] = caseFoldCharset(p);\r\n          } else if (ch0 !== '\\\\') {\r\n            // TODO: handle letters in numeric escapes.\r\n            parts[i] = p.replace(\r\n                /[a-zA-Z]/g,\r\n                function (ch) {\r\n                  var cc = ch.charCodeAt(0);\r\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\r\n                });\r\n          }\r\n        }\r\n      }\r\n  \r\n      return parts.join('');\r\n    }\r\n  \r\n    var rewritten = [];\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\r\n      rewritten.push(\r\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\r\n    }\r\n  \r\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\r\n  }\r\n\r\n  /**\r\n   * Split markup into a string of source code and an array mapping ranges in\r\n   * that string to the text nodes in which they appear.\r\n   *\r\n   * <p>\r\n   * The HTML DOM structure:</p>\r\n   * <pre>\r\n   * (Element   \"p\"\r\n   *   (Element \"b\"\r\n   *     (Text  \"print \"))       ; #1\r\n   *   (Text    \"'Hello '\")      ; #2\r\n   *   (Element \"br\")            ; #3\r\n   *   (Text    \"  + 'World';\")) ; #4\r\n   * </pre>\r\n   * <p>\r\n   * corresponds to the HTML\r\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\r\n   *\r\n   * <p>\r\n   * It will produce the output:</p>\r\n   * <pre>\r\n   * {\r\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\r\n   *   //                     1          2\r\n   *   //           012345678901234 5678901234567\r\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\r\n   * }\r\n   * </pre>\r\n   * <p>\r\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\r\n   * on for the other text nodes.\r\n   * </p>\r\n   *\r\n   * <p>\r\n   * The {@code} spans array is an array of pairs.  Even elements are the start\r\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\r\n   * that contain the text for those substrings.\r\n   * Substrings continue until the next index or the end of the source.\r\n   * </p>\r\n   *\r\n   * @param {Node} node an HTML DOM subtree containing source-code.\r\n   * @param {boolean|number} isPreformatted truthy if white-space in\r\n   *    text nodes should be considered significant.\r\n   * @return {SourceSpansT} source code and the nodes in which they occur.\r\n   */\r\n  function extractSourceSpans(node, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n  \r\n    var chunks = [];\r\n    var length = 0;\r\n    var spans = [];\r\n    var k = 0;\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1) {  // Element\r\n        if (nocode.test(node.className)) { return; }\r\n        for (var child = node.firstChild; child; child = child.nextSibling) {\r\n          walk(child);\r\n        }\r\n        var nodeName = node.nodeName.toLowerCase();\r\n        if ('br' === nodeName || 'li' === nodeName) {\r\n          chunks[k] = '\\n';\r\n          spans[k << 1] = length++;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      } else if (type == 3 || type == 4) {  // Text\r\n        var text = node.nodeValue;\r\n        if (text.length) {\r\n          if (!isPreformatted) {\r\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\r\n          } else {\r\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\r\n          }\r\n          // TODO: handle tabs here?\r\n          chunks[k] = text;\r\n          spans[k << 1] = length;\r\n          length += text.length;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      }\r\n    }\r\n  \r\n    walk(node);\r\n  \r\n    return {\r\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\r\n      spans: spans\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply the given language handler to sourceCode and add the resulting\r\n   * decorations to out.\r\n   * @param {!Element} sourceNode\r\n   * @param {number} basePos the index of sourceCode within the chunk of source\r\n   *    whose decorations are already present on out.\r\n   * @param {string} sourceCode\r\n   * @param {function(JobT)} langHandler\r\n   * @param {DecorationsT} out\r\n   */\r\n  function appendDecorations(\r\n      sourceNode, basePos, sourceCode, langHandler, out) {\r\n    if (!sourceCode) { return; }\r\n    /** @type {JobT} */\r\n    var job = {\r\n      sourceNode: sourceNode,\r\n      pre: 1,\r\n      langExtension: null,\r\n      numberLines: null,\r\n      sourceCode: sourceCode,\r\n      spans: null,\r\n      basePos: basePos,\r\n      decorations: null\r\n    };\r\n    langHandler(job);\r\n    out.push.apply(out, job.decorations);\r\n  }\r\n\r\n  var notWs = /\\S/;\r\n\r\n  /**\r\n   * Given an element, if it contains only one child element and any text nodes\r\n   * it contains contain only space characters, return the sole child element.\r\n   * Otherwise returns undefined.\r\n   * <p>\r\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\r\n   * there is a single child element that contains all the non-space textual\r\n   * content, but not to return anything where there are multiple child elements\r\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\r\n   * is textual content.\r\n   */\r\n  function childContentWrapper(element) {\r\n    var wrapper = undefined;\r\n    for (var c = element.firstChild; c; c = c.nextSibling) {\r\n      var type = c.nodeType;\r\n      wrapper = (type === 1)  // Element Node\r\n          ? (wrapper ? element : c)\r\n          : (type === 3)  // Text Node\r\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\r\n          : wrapper;\r\n    }\r\n    return wrapper === element ? undefined : wrapper;\r\n  }\r\n\r\n  /** Given triples of [style, pattern, context] returns a lexing function,\r\n    * The lexing function interprets the patterns to find token boundaries and\r\n    * returns a decoration list of the form\r\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\r\n    * where index_n is an index into the sourceCode, and style_n is a style\r\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\r\n    * all characters in sourceCode[index_n-1:index_n].\r\n    *\r\n    * The stylePatterns is a list whose elements have the form\r\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\r\n    *\r\n    * Style is a style constant like PR_PLAIN, or can be a string of the\r\n    * form 'lang-FOO', where FOO is a language extension describing the\r\n    * language of the portion of the token in $1 after pattern executes.\r\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\r\n    * '(hello (world))', then that portion of the token will be passed to the\r\n    * registered lisp handler for formatting.\r\n    * The text before and after group 1 will be restyled using this decorator\r\n    * so decorators should take care that this doesn't result in infinite\r\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\r\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\r\n    * '<script>foo()<\\/script>', which would cause the current decorator to\r\n    * be called with '<script>' which would not match the same rule since\r\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\r\n    * the generic tag rule.  The handler registered for the 'js' extension would\r\n    * then be called with 'foo()', and finally, the current decorator would\r\n    * be called with '<\\/script>' which would not match the original rule and\r\n    * so the generic tag rule would identify it as a tag.\r\n    *\r\n    * Pattern must only match prefixes, and if it matches a prefix, then that\r\n    * match is considered a token with the same style.\r\n    *\r\n    * Context is applied to the last non-whitespace, non-comment token\r\n    * recognized.\r\n    *\r\n    * Shortcut is an optional string of characters, any of which, if the first\r\n    * character, gurantee that this pattern and only this pattern matches.\r\n    *\r\n    * @param {Array} shortcutStylePatterns patterns that always start with\r\n    *   a known character.  Must have a shortcut string.\r\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\r\n    *   order if the shortcut ones fail.  May have shortcuts.\r\n    *\r\n    * @return {function (JobT)} a function that takes an undecorated job and\r\n    *   attaches a list of decorations.\r\n    */\r\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\r\n    var shortcuts = {};\r\n    var tokenizer;\r\n    (function () {\r\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\r\n      var allRegexs = [];\r\n      var regexKeys = {};\r\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\r\n        var patternParts = allPatterns[i];\r\n        var shortcutChars = patternParts[3];\r\n        if (shortcutChars) {\r\n          for (var c = shortcutChars.length; --c >= 0;) {\r\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\r\n          }\r\n        }\r\n        var regex = patternParts[1];\r\n        var k = '' + regex;\r\n        if (!regexKeys.hasOwnProperty(k)) {\r\n          allRegexs.push(regex);\r\n          regexKeys[k] = null;\r\n        }\r\n      }\r\n      allRegexs.push(/[\\0-\\uffff]/);\r\n      tokenizer = combinePrefixPatterns(allRegexs);\r\n    })();\r\n\r\n    var nPatterns = fallthroughStylePatterns.length;\r\n\r\n    /**\r\n     * Lexes job.sourceCode and attaches an output array job.decorations of\r\n     * style classes preceded by the position at which they start in\r\n     * job.sourceCode in order.\r\n     *\r\n     * @type{function (JobT)}\r\n     */\r\n    var decorate = function (job) {\r\n      var sourceCode = job.sourceCode, basePos = job.basePos;\r\n      var sourceNode = job.sourceNode;\r\n      /** Even entries are positions in source in ascending order.  Odd enties\r\n        * are style markers (e.g., PR_COMMENT) that run from that position until\r\n        * the end.\r\n        * @type {DecorationsT}\r\n        */\r\n      var decorations = [basePos, PR_PLAIN];\r\n      var pos = 0;  // index into sourceCode\r\n      var tokens = sourceCode.match(tokenizer) || [];\r\n      var styleCache = {};\r\n\r\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\r\n        var token = tokens[ti];\r\n        var style = styleCache[token];\r\n        var match = void 0;\r\n\r\n        var isEmbedded;\r\n        if (typeof style === 'string') {\r\n          isEmbedded = false;\r\n        } else {\r\n          var patternParts = shortcuts[token.charAt(0)];\r\n          if (patternParts) {\r\n            match = token.match(patternParts[1]);\r\n            style = patternParts[0];\r\n          } else {\r\n            for (var i = 0; i < nPatterns; ++i) {\r\n              patternParts = fallthroughStylePatterns[i];\r\n              match = token.match(patternParts[1]);\r\n              if (match) {\r\n                style = patternParts[0];\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (!match) {  // make sure that we make progress\r\n              style = PR_PLAIN;\r\n            }\r\n          }\r\n\r\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\r\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\r\n            isEmbedded = false;\r\n            style = PR_SOURCE;\r\n          }\r\n\r\n          if (!isEmbedded) { styleCache[token] = style; }\r\n        }\r\n\r\n        var tokenStart = pos;\r\n        pos += token.length;\r\n\r\n        if (!isEmbedded) {\r\n          decorations.push(basePos + tokenStart, style);\r\n        } else {  // Treat group 1 as an embedded block of source code.\r\n          var embeddedSource = match[1];\r\n          var embeddedSourceStart = token.indexOf(embeddedSource);\r\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\r\n          if (match[2]) {\r\n            // If embeddedSource can be blank, then it would match at the\r\n            // beginning which would cause us to infinitely recurse on the\r\n            // entire token, so we catch the right context in match[2].\r\n            embeddedSourceEnd = token.length - match[2].length;\r\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\r\n          }\r\n          var lang = style.substring(5);\r\n          // Decorate the left of the embedded source\r\n          appendDecorations(\r\n              sourceNode,\r\n              basePos + tokenStart,\r\n              token.substring(0, embeddedSourceStart),\r\n              decorate, decorations);\r\n          // Decorate the embedded source\r\n          appendDecorations(\r\n              sourceNode,\r\n              basePos + tokenStart + embeddedSourceStart,\r\n              embeddedSource,\r\n              langHandlerForExtension(lang, embeddedSource),\r\n              decorations);\r\n          // Decorate the right of the embedded section\r\n          appendDecorations(\r\n              sourceNode,\r\n              basePos + tokenStart + embeddedSourceEnd,\r\n              token.substring(embeddedSourceEnd),\r\n              decorate, decorations);\r\n        }\r\n      }\r\n      job.decorations = decorations;\r\n    };\r\n    return decorate;\r\n  }\r\n\r\n  /** returns a function that produces a list of decorations from source text.\r\n    *\r\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\r\n    * escape.  It does not recognize perl's qq() style strings.\r\n    * It has no special handling for double delimiter escapes as in basic, or\r\n    * the tripled delimiters used in python, but should work on those regardless\r\n    * although in those cases a single string literal may be broken up into\r\n    * multiple adjacent string literals.\r\n    *\r\n    * It recognizes C, C++, and shell style comments.\r\n    *\r\n    * @param {Object} options a set of optional parameters.\r\n    * @return {function (JobT)} a function that examines the source code\r\n    *     in the input job and builds a decoration list which it attaches to\r\n    *     the job.\r\n    */\r\n  function sourceDecorator(options) {\r\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\r\n    if (options['tripleQuotedStrings']) {\r\n      // '''multi-line-string''', 'single-line-string', and double-quoted\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\r\n           null, '\\'\"']);\r\n    } else if (options['multiLineStrings']) {\r\n      // 'multi-line-string', \"multi-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\r\n           null, '\\'\"`']);\r\n    } else {\r\n      // 'single-line-string', \"single-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,\r\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\r\n           null, '\"\\'']);\r\n    }\r\n    if (options['verbatimStrings']) {\r\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\r\n      fallthroughStylePatterns.push(\r\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\r\n    }\r\n    var hc = options['hashComments'];\r\n    if (hc) {\r\n      if (options['cStyleComments']) {\r\n        if (hc > 1) {  // multiline hash comments\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\r\n        } else {\r\n          // Stop C preprocessor declarations at an unclosed open comment\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\r\n               null, '#']);\r\n        }\r\n        // #include <stdio.h>\r\n        fallthroughStylePatterns.push(\r\n            [PR_STRING,\r\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\r\n             null]);\r\n      } else {\r\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\r\n      }\r\n    }\r\n    if (options['cStyleComments']) {\r\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\r\n      fallthroughStylePatterns.push(\r\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\r\n    }\r\n    var regexLiterals = options['regexLiterals'];\r\n    if (regexLiterals) {\r\n      /**\r\n       * @const\r\n       */\r\n      var regexExcls = regexLiterals > 1\r\n        ? ''  // Multiline regex literals\r\n        : '\\n\\r';\r\n      /**\r\n       * @const\r\n       */\r\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\r\n      /**\r\n       * @const\r\n       */\r\n      var REGEX_LITERAL = (\r\n          // A regular expression literal starts with a slash that is\r\n          // not followed by * or / so that it is not confused with\r\n          // comments.\r\n          '/(?=[^/*' + regexExcls + '])'\r\n          // and then contains any number of raw characters,\r\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\r\n          // escape sequences (\\x5C),\r\n          +    '|\\\\x5C' + regexAny\r\n          // or non-nesting character sets (\\x5B\\x5D);\r\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\r\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\r\n          // finally closed by a /.\r\n          + '/');\r\n      fallthroughStylePatterns.push(\r\n          ['lang-regex',\r\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\r\n           ]);\r\n    }\r\n\r\n    var types = options['types'];\r\n    if (types) {\r\n      fallthroughStylePatterns.push([PR_TYPE, types]);\r\n    }\r\n\r\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\r\n    if (keywords.length) {\r\n      fallthroughStylePatterns.push(\r\n          [PR_KEYWORD,\r\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\r\n           null]);\r\n    }\r\n\r\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\r\n\r\n    var punctuation =\r\n      // The Bash man page says\r\n\r\n      // A word is a sequence of characters considered as a single\r\n      // unit by GRUB. Words are separated by metacharacters,\r\n      // which are the following plus space, tab, and newline: { }\r\n      // | & $ ; < >\r\n      // ...\r\n\r\n      // A word beginning with # causes that word and all remaining\r\n      // characters on that line to be ignored.\r\n\r\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\r\n      // comment but empirically\r\n      // $ echo {#}\r\n      // {#}\r\n      // $ echo \\$#\r\n      // $#\r\n      // $ echo }#\r\n      // }#\r\n\r\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\r\n\r\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\r\n      // suggests that this definition is compatible with a\r\n      // default mode that tries to use a single token definition\r\n      // to recognize both bash/python style comments and C\r\n      // preprocessor directives.\r\n\r\n      // This definition of punctuation does not include # in the list of\r\n      // follow-on exclusions, so # will not be broken before if preceeded\r\n      // by a punctuation character.  We could try to exclude # after\r\n      // [|&;<>] but that doesn't seem to cause many major problems.\r\n      // If that does turn out to be a problem, we should change the below\r\n      // when hc is truthy to include # in the run of punctuation characters\r\n      // only when not followint [|&;<>].\r\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\r\n    if (options['regexLiterals']) {\r\n      punctuation += '(?!\\s*\\/)';\r\n    }\r\n\r\n    fallthroughStylePatterns.push(\r\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\r\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\r\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_LITERAL,\r\n         new RegExp(\r\n             '^(?:'\r\n             // A hex number\r\n             + '0x[a-f0-9]+'\r\n             // or an octal or decimal number,\r\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\r\n             // possibly in scientific notation\r\n             + '(?:e[+\\\\-]?\\\\d+)?'\r\n             + ')'\r\n             // with an optional modifier like UL for unsigned long\r\n             + '[a-z]*', 'i'),\r\n         null, '0123456789'],\r\n        // Don't treat escaped quotes in bash as starting strings.\r\n        // See issue 144.\r\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\r\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\r\n\r\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\r\n  }\r\n\r\n  var decorateSource = sourceDecorator({\r\n        'keywords': ALL_KEYWORDS,\r\n        'hashComments': true,\r\n        'cStyleComments': true,\r\n        'multiLineStrings': true,\r\n        'regexLiterals': true\r\n      });\r\n\r\n  /**\r\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\r\n   * list item.\r\n   *\r\n   * @param {Node} node modified in place.  Its content is pulled into an\r\n   *     HTMLOListElement, and each line is moved into a separate list item.\r\n   *     This requires cloning elements, so the input might not have unique\r\n   *     IDs after numbering.\r\n   * @param {number|null|boolean} startLineNum\r\n   *     If truthy, coerced to an integer which is the 1-indexed line number\r\n   *     of the first line of code.  The number of the first line will be\r\n   *     attached to the list.\r\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\r\n   *     be treated as significant.\r\n   */\r\n  function numberLines(node, startLineNum, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n    var lineBreak = /\\r\\n?|\\n/;\r\n  \r\n    var document = node.ownerDocument;\r\n  \r\n    var li = document.createElement('li');\r\n    while (node.firstChild) {\r\n      li.appendChild(node.firstChild);\r\n    }\r\n    // An array of lines.  We split below, so this is initialized to one\r\n    // un-split line.\r\n    var listItems = [li];\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1 && !nocode.test(node.className)) {  // Element\r\n        if ('br' === node.nodeName) {\r\n          breakAfter(node);\r\n          // Discard the <BR> since it is now flush against a </LI>.\r\n          if (node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        } else {\r\n          for (var child = node.firstChild; child; child = child.nextSibling) {\r\n            walk(child);\r\n          }\r\n        }\r\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\r\n        var text = node.nodeValue;\r\n        var match = text.match(lineBreak);\r\n        if (match) {\r\n          var firstLine = text.substring(0, match.index);\r\n          node.nodeValue = firstLine;\r\n          var tail = text.substring(match.index + match[0].length);\r\n          if (tail) {\r\n            var parent = node.parentNode;\r\n            parent.insertBefore(\r\n              document.createTextNode(tail), node.nextSibling);\r\n          }\r\n          breakAfter(node);\r\n          if (!firstLine) {\r\n            // Don't leave blank text nodes in the DOM.\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Split a line after the given node.\r\n    function breakAfter(lineEndNode) {\r\n      // If there's nothing to the right, then we can skip ending the line\r\n      // here, and move root-wards since splitting just before an end-tag\r\n      // would require us to create a bunch of empty copies.\r\n      while (!lineEndNode.nextSibling) {\r\n        lineEndNode = lineEndNode.parentNode;\r\n        if (!lineEndNode) { return; }\r\n      }\r\n  \r\n      function breakLeftOf(limit, copy) {\r\n        // Clone shallowly if this node needs to be on both sides of the break.\r\n        var rightSide = copy ? limit.cloneNode(false) : limit;\r\n        var parent = limit.parentNode;\r\n        if (parent) {\r\n          // We clone the parent chain.\r\n          // This helps us resurrect important styling elements that cross lines.\r\n          // E.g. in <i>Foo<br>Bar</i>\r\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\r\n          var parentClone = breakLeftOf(parent, 1);\r\n          // Move the clone and everything to the right of the original\r\n          // onto the cloned parent.\r\n          var next = limit.nextSibling;\r\n          parentClone.appendChild(rightSide);\r\n          for (var sibling = next; sibling; sibling = next) {\r\n            next = sibling.nextSibling;\r\n            parentClone.appendChild(sibling);\r\n          }\r\n        }\r\n        return rightSide;\r\n      }\r\n  \r\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\r\n  \r\n      // Walk the parent chain until we reach an unattached LI.\r\n      for (var parent;\r\n           // Check nodeType since IE invents document fragments.\r\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\r\n        copiedListItem = parent;\r\n      }\r\n      // Put it on the list of lines for later processing.\r\n      listItems.push(copiedListItem);\r\n    }\r\n  \r\n    // Split lines while there are lines left to split.\r\n    for (var i = 0;  // Number of lines that have been split so far.\r\n         i < listItems.length;  // length updated by breakAfter calls.\r\n         ++i) {\r\n      walk(listItems[i]);\r\n    }\r\n  \r\n    // Make sure numeric indices show correctly.\r\n    if (startLineNum === (startLineNum|0)) {\r\n      listItems[0].setAttribute('value', startLineNum);\r\n    }\r\n  \r\n    var ol = document.createElement('ol');\r\n    ol.className = 'linenums';\r\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\r\n    for (var i = 0, n = listItems.length; i < n; ++i) {\r\n      li = listItems[i];\r\n      // Stick a class on the LIs so that stylesheets can\r\n      // color odd/even rows, or any other row pattern that\r\n      // is co-prime with 10.\r\n      li.className = 'L' + ((i + offset) % 10);\r\n      if (!li.firstChild) {\r\n        li.appendChild(document.createTextNode('\\xA0'));\r\n      }\r\n      ol.appendChild(li);\r\n    }\r\n  \r\n    node.appendChild(ol);\r\n  }\r\n\r\n  /**\r\n   * Breaks {@code job.sourceCode} around style boundaries in\r\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\r\n   * @param {JobT} job\r\n   * @private\r\n   */\r\n  function recombineTagsAndDecorations(job) {\r\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\r\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\r\n    var newlineRe = /\\n/g;\r\n  \r\n    var source = job.sourceCode;\r\n    var sourceLength = source.length;\r\n    // Index into source after the last code-unit recombined.\r\n    var sourceIndex = 0;\r\n  \r\n    var spans = job.spans;\r\n    var nSpans = spans.length;\r\n    // Index into spans after the last span which ends at or before sourceIndex.\r\n    var spanIndex = 0;\r\n  \r\n    var decorations = job.decorations;\r\n    var nDecorations = decorations.length;\r\n    // Index into decorations after the last decoration which ends at or before\r\n    // sourceIndex.\r\n    var decorationIndex = 0;\r\n  \r\n    // Remove all zero-length decorations.\r\n    decorations[nDecorations] = sourceLength;\r\n    var decPos, i;\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      if (decorations[i] !== decorations[i + 2]) {\r\n        decorations[decPos++] = decorations[i++];\r\n        decorations[decPos++] = decorations[i++];\r\n      } else {\r\n        i += 2;\r\n      }\r\n    }\r\n    nDecorations = decPos;\r\n  \r\n    // Simplify decorations.\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      var startPos = decorations[i];\r\n      // Conflate all adjacent decorations that use the same style.\r\n      var startDec = decorations[i + 1];\r\n      var end = i + 2;\r\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\r\n        end += 2;\r\n      }\r\n      decorations[decPos++] = startPos;\r\n      decorations[decPos++] = startDec;\r\n      i = end;\r\n    }\r\n  \r\n    nDecorations = decorations.length = decPos;\r\n  \r\n    var sourceNode = job.sourceNode;\r\n    var oldDisplay = \"\";\r\n    if (sourceNode) {\r\n      oldDisplay = sourceNode.style.display;\r\n      sourceNode.style.display = 'none';\r\n    }\r\n    try {\r\n      var decoration = null;\r\n      while (spanIndex < nSpans) {\r\n        var spanStart = spans[spanIndex];\r\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\r\n            || sourceLength;\r\n  \r\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\r\n  \r\n        var end = Math.min(spanEnd, decEnd);\r\n  \r\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\r\n        var styledText;\r\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\r\n            // Don't introduce spans around empty text nodes.\r\n            && (styledText = source.substring(sourceIndex, end))) {\r\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\r\n          // code to display with spaces instead of line breaks.\r\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\r\n          // space to appear at the beginning of every line but the first.\r\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\r\n          if (isIE8OrEarlier) {\r\n            styledText = styledText.replace(newlineRe, '\\r');\r\n          }\r\n          textNode.nodeValue = styledText;\r\n          var document = textNode.ownerDocument;\r\n          var span = document.createElement('span');\r\n          span.className = decorations[decorationIndex + 1];\r\n          var parentNode = textNode.parentNode;\r\n          parentNode.replaceChild(span, textNode);\r\n          span.appendChild(textNode);\r\n          if (sourceIndex < spanEnd) {  // Split off a text node.\r\n            spans[spanIndex + 1] = textNode\r\n                // TODO: Possibly optimize by using '' if there's no flicker.\r\n                = document.createTextNode(source.substring(end, spanEnd));\r\n            parentNode.insertBefore(textNode, span.nextSibling);\r\n          }\r\n        }\r\n  \r\n        sourceIndex = end;\r\n  \r\n        if (sourceIndex >= spanEnd) {\r\n          spanIndex += 2;\r\n        }\r\n        if (sourceIndex >= decEnd) {\r\n          decorationIndex += 2;\r\n        }\r\n      }\r\n    } finally {\r\n      if (sourceNode) {\r\n        sourceNode.style.display = oldDisplay;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Maps language-specific file extensions to handlers. */\r\n  var langHandlerRegistry = {};\r\n  /** Register a language handler for the given file extensions.\r\n    * @param {function (JobT)} handler a function from source code to a list\r\n    *      of decorations.  Takes a single argument job which describes the\r\n    *      state of the computation and attaches the decorations to it.\r\n    * @param {Array.<string>} fileExtensions\r\n    */\r\n  function registerLangHandler(handler, fileExtensions) {\r\n    for (var i = fileExtensions.length; --i >= 0;) {\r\n      var ext = fileExtensions[i];\r\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\r\n        langHandlerRegistry[ext] = handler;\r\n      } else if (win['console']) {\r\n        console['warn']('cannot override language handler %s', ext);\r\n      }\r\n    }\r\n  }\r\n  function langHandlerForExtension(extension, source) {\r\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\r\n      // Treat it as markup if the first non whitespace character is a < and\r\n      // the last non-whitespace character is a >.\r\n      extension = /^\\s*</.test(source)\r\n          ? 'default-markup'\r\n          : 'default-code';\r\n    }\r\n    return langHandlerRegistry[extension];\r\n  }\r\n  registerLangHandler(decorateSource, ['default-code']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [],\r\n          [\r\n           [PR_PLAIN,       /^[^<?]+/],\r\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\r\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\r\n           // Unescaped content in an unknown language\r\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\r\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\r\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\r\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\r\n           // Unescaped content in javascript.  (Or possibly vbscript).\r\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\r\n           // Contains unescaped stylesheet content\r\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\r\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\r\n          ]),\r\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [\r\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\r\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\r\n           ],\r\n          [\r\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\r\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\r\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\r\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\r\n           ]),\r\n      ['in.tag']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CPP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'types': C_TYPES\r\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': 'null,true,false'\r\n        }), ['json']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CSHARP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'verbatimStrings': true,\r\n          'types': C_TYPES\r\n        }), ['cs']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JAVA_KEYWORDS,\r\n          'cStyleComments': true\r\n        }), ['java']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': SH_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true\r\n        }), ['bash', 'bsh', 'csh', 'sh']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PYTHON_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'tripleQuotedStrings': true\r\n        }), ['cv', 'py', 'python']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PERL_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': 2  // multiline regex literals\r\n        }), ['perl', 'pl', 'pm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': RUBY_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': true\r\n        }), ['rb', 'ruby']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JSCRIPT_KEYWORDS,\r\n          'cStyleComments': true,\r\n          'regexLiterals': true\r\n        }), ['javascript', 'js', 'ts', 'typescript']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': COFFEE_KEYWORDS,\r\n          'hashComments': 3,  // ### style block comments\r\n          'cStyleComments': true,\r\n          'multilineStrings': true,\r\n          'tripleQuotedStrings': true,\r\n          'regexLiterals': true\r\n        }), ['coffee']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\r\n\r\n  /** @param {JobT} job */\r\n  function applyDecorator(job) {\r\n    var opt_langExtension = job.langExtension;\r\n\r\n    try {\r\n      // Extract tags, and convert the source code to plain text.\r\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\r\n      /** Plain text. @type {string} */\r\n      var source = sourceAndSpans.sourceCode;\r\n      job.sourceCode = source;\r\n      job.spans = sourceAndSpans.spans;\r\n      job.basePos = 0;\r\n\r\n      // Apply the appropriate language handler\r\n      langHandlerForExtension(opt_langExtension, source)(job);\r\n\r\n      // Integrate the decorations and tags back into the source code,\r\n      // modifying the sourceNode in place.\r\n      recombineTagsAndDecorations(job);\r\n    } catch (e) {\r\n      if (win['console']) {\r\n        console['log'](e && e['stack'] || e);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pretty print a chunk of code.\r\n   * @param sourceCodeHtml {string} The HTML to pretty print.\r\n   * @param opt_langExtension {string} The language name to use.\r\n   *     Typically, a filename extension like 'cpp' or 'java'.\r\n   * @param opt_numberLines {number|boolean} True to number lines,\r\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n   */\r\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\r\n    /** @type{number|boolean} */\r\n    var nl = opt_numberLines || false;\r\n    /** @type{string|null} */\r\n    var langExtension = opt_langExtension || null;\r\n    /** @type{!Element} */\r\n    var container = document.createElement('div');\r\n    // This could cause images to load and onload listeners to fire.\r\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\r\n    // We assume that the inner HTML is from a trusted source.\r\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\r\n    // when it is injected into a <pre> tag.\r\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\r\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\r\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\r\n    container = /** @type{!Element} */(container.firstChild);\r\n    if (nl) {\r\n      numberLines(container, nl, true);\r\n    }\r\n\r\n    /** @type{JobT} */\r\n    var job = {\r\n      langExtension: langExtension,\r\n      numberLines: nl,\r\n      sourceNode: container,\r\n      pre: 1,\r\n      sourceCode: null,\r\n      basePos: null,\r\n      spans: null,\r\n      decorations: null\r\n    };\r\n    applyDecorator(job);\r\n    return container.innerHTML;\r\n  }\r\n\r\n   /**\r\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n    * {@code class=prettyprint} and prettify them.\r\n    *\r\n    * @param {Function} opt_whenDone called when prettifying is done.\r\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n    *   containing all the elements to pretty print.\r\n    *   Defaults to {@code document.body}.\r\n    */\r\n  function $prettyPrint(opt_whenDone, opt_root) {\r\n    var root = opt_root || document.body;\r\n    var doc = root.ownerDocument || document;\r\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\r\n    // fetch a list of nodes to rewrite\r\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\r\n    var elements = [];\r\n    for (var i = 0; i < codeSegments.length; ++i) {\r\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\r\n        elements.push(codeSegments[i][j]);\r\n      }\r\n    }\r\n    codeSegments = null;\r\n\r\n    var clock = Date;\r\n    if (!clock['now']) {\r\n      clock = { 'now': function () { return +(new Date); } };\r\n    }\r\n\r\n    // The loop is broken into a series of continuations to make sure that we\r\n    // don't make the browser unresponsive when rewriting a large page.\r\n    var k = 0;\r\n\r\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\r\n    var prettyPrintRe = /\\bprettyprint\\b/;\r\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\r\n    var preformattedTagNameRe = /pre|xmp/i;\r\n    var codeRe = /^code$/i;\r\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\r\n    var EMPTY = {};\r\n\r\n    function doWork() {\r\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\r\n                     clock['now']() + 250 /* ms */ :\r\n                     Infinity);\r\n      for (; k < elements.length && clock['now']() < endTime; k++) {\r\n        var cs = elements[k];\r\n\r\n        // Look for a preceding comment like\r\n        // <?prettify lang=\"...\" linenums=\"...\"?>\r\n        var attrs = EMPTY;\r\n        {\r\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\r\n            var nt = preceder.nodeType;\r\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\r\n            // like <!--?foo?-->, but in XML is a processing instruction\r\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\r\n            if (value\r\n                ? !/^\\??prettify\\b/.test(value)\r\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\r\n              // Skip over white-space text nodes but not others.\r\n              break;\r\n            }\r\n            if (value) {\r\n              attrs = {};\r\n              value.replace(\r\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\r\n                function (_, name, value) { attrs[name] = value; });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        var className = cs.className;\r\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\r\n            // Don't redo this if we've already done it.\r\n            // This allows recalling pretty print to just prettyprint elements\r\n            // that have been added to the page since last call.\r\n            && !prettyPrintedRe.test(className)) {\r\n\r\n          // make sure this is not nested in an already prettified element\r\n          var nested = false;\r\n          for (var p = cs.parentNode; p; p = p.parentNode) {\r\n            var tn = p.tagName;\r\n            if (preCodeXmpRe.test(tn)\r\n                && p.className && prettyPrintRe.test(p.className)) {\r\n              nested = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!nested) {\r\n            // Mark done.  If we fail to prettyprint for whatever reason,\r\n            // we shouldn't try again.\r\n            cs.className += ' prettyprinted';\r\n\r\n            // If the classes includes a language extensions, use it.\r\n            // Language extensions can be specified like\r\n            //     <pre class=\"prettyprint lang-cpp\">\r\n            // the language extension \"cpp\" is used to find a language handler\r\n            // as passed to PR.registerLangHandler.\r\n            // HTML5 recommends that a language be specified using \"language-\"\r\n            // as the prefix instead.  Google Code Prettify supports both.\r\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\r\n            var langExtension = attrs['lang'];\r\n            if (!langExtension) {\r\n              langExtension = className.match(langExtensionRe);\r\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\r\n              var wrapper;\r\n              if (!langExtension && (wrapper = childContentWrapper(cs))\r\n                  && codeRe.test(wrapper.tagName)) {\r\n                langExtension = wrapper.className.match(langExtensionRe);\r\n              }\r\n\r\n              if (langExtension) { langExtension = langExtension[1]; }\r\n            }\r\n\r\n            var preformatted;\r\n            if (preformattedTagNameRe.test(cs.tagName)) {\r\n              preformatted = 1;\r\n            } else {\r\n              var currentStyle = cs['currentStyle'];\r\n              var defaultView = doc.defaultView;\r\n              var whitespace = (\r\n                  currentStyle\r\n                  ? currentStyle['whiteSpace']\r\n                  : (defaultView\r\n                     && defaultView.getComputedStyle)\r\n                  ? defaultView.getComputedStyle(cs, null)\r\n                  .getPropertyValue('white-space')\r\n                  : 0);\r\n              preformatted = whitespace\r\n                  && 'pre' === whitespace.substring(0, 3);\r\n            }\r\n\r\n            // Look for a class like linenums or linenums:<n> where <n> is the\r\n            // 1-indexed number of the first line.\r\n            var lineNums = attrs['linenums'];\r\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\r\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\r\n              lineNums =\r\n                lineNums\r\n                ? lineNums[1] && lineNums[1].length\r\n                  ? +lineNums[1] : true\r\n                : false;\r\n            }\r\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\r\n\r\n            // do the pretty printing\r\n            var prettyPrintingJob = {\r\n              langExtension: langExtension,\r\n              sourceNode: cs,\r\n              numberLines: lineNums,\r\n              pre: preformatted,\r\n              sourceCode: null,\r\n              basePos: null,\r\n              spans: null,\r\n              decorations: null\r\n            };\r\n            applyDecorator(prettyPrintingJob);\r\n          }\r\n        }\r\n      }\r\n      if (k < elements.length) {\r\n        // finish up in a continuation\r\n        win.setTimeout(doWork, 250);\r\n      } else if ('function' === typeof opt_whenDone) {\r\n        opt_whenDone();\r\n      }\r\n    }\r\n\r\n    doWork();\r\n  }\r\n\r\n  /**\r\n   * Contains functions for creating and registering new language handlers.\r\n   * @type {Object}\r\n   */\r\n  var PR = win['PR'] = {\r\n        'createSimpleLexer': createSimpleLexer,\r\n        'registerLangHandler': registerLangHandler,\r\n        'sourceDecorator': sourceDecorator,\r\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\r\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\r\n        'PR_COMMENT': PR_COMMENT,\r\n        'PR_DECLARATION': PR_DECLARATION,\r\n        'PR_KEYWORD': PR_KEYWORD,\r\n        'PR_LITERAL': PR_LITERAL,\r\n        'PR_NOCODE': PR_NOCODE,\r\n        'PR_PLAIN': PR_PLAIN,\r\n        'PR_PUNCTUATION': PR_PUNCTUATION,\r\n        'PR_SOURCE': PR_SOURCE,\r\n        'PR_STRING': PR_STRING,\r\n        'PR_TAG': PR_TAG,\r\n        'PR_TYPE': PR_TYPE,\r\n        'prettyPrintOne':\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\r\n             : (prettyPrintOne = $prettyPrintOne),\r\n        'prettyPrint': prettyPrint =\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrint'] = $prettyPrint)\r\n             : (prettyPrint = $prettyPrint)\r\n      };\r\n\r\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\r\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\r\n  // The Asynchronous Module Definition (AMD) API specifies a\r\n  // mechanism for defining modules such that the module and its\r\n  // dependencies can be asynchronously loaded.\r\n  // ...\r\n  // To allow a clear indicator that a global define function (as\r\n  // needed for script src browser loading) conforms to the AMD API,\r\n  // any global define function SHOULD have a property called \"amd\"\r\n  // whose value is an object. This helps avoid conflict with any\r\n  // other existing JavaScript code that could have defined a define()\r\n  // function that does not conform to the AMD API.\r\n  var define = win['define'];\r\n  if (typeof define === \"function\" && define['amd']) {\r\n    define(\"google-code-prettify\", [], function () {\r\n      return PR;\r\n    });\r\n  }\r\n})();\r\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nrequire(\"code-prettify\");\n\nwindow.addEventListener(\"load\", function () {\n\n\tPR.prettyPrint();\n\n\t// store tabs variables asdasdsad\n\tvar tabs = document.querySelectorAll(\"ul.nav-tabs > li\");\n\tfor (var i = 0; i < tabs.length; i++) {\n\t\ttabs[i].addEventListener(\"click\", switchTab);\n\t}\n\n\tfunction switchTab(event) {\n\t\tevent.preventDefault();\n\n\t\tdocument.querySelector(\"ul.nav-tabs li.active\").classList.remove(\"active\");\n\t\tdocument.querySelector(\".tab-pane.active\").classList.remove(\"active\");\n\n\t\tvar clickedTab = event.currentTarget;\n\t\tvar anchor = event.target;\n\t\tvar activePaneID = anchor.getAttribute(\"href\");\n\n\t\tclickedTab.classList.add(\"active\");\n\t\tdocument.querySelector(activePaneID).classList.add(\"active\");\n\t}\n});\n\njQuery(document).ready(function ($) {\n\t$(document).on('click', '.js-image-upload', function (e) {\n\t\te.preventDefault();\n\t\tvar $button = $(this);\n\n\t\tvar file_frame = wp.media.frames.file_frame = wp.media({\n\t\t\ttitle: 'Select or Upload an Image',\n\t\t\tlibrary: {\n\t\t\t\ttype: 'image' // mime type\n\t\t\t},\n\t\t\tbutton: {\n\t\t\t\ttext: 'Select Image'\n\t\t\t},\n\t\t\tmultiple: false\n\t\t});\n\n\t\tfile_frame.on('select', function () {\n\t\t\tvar attachment = file_frame.state().get('selection').first().toJSON();\n\t\t\t$button.siblings('.image-upload').val(attachment.url).trigger(\"change\");\n\t\t});\n\n\t\tfile_frame.open();\n\t});\n});\n\n},{\"code-prettify\":1}]},{},[2]);\n"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","window","win","FLOW_CONTROL_KEYWORDS","COMMON_KEYWORDS","CPP_KEYWORDS","JAVA_KEYWORDS","CSHARP_KEYWORDS","JSCRIPT_KEYWORDS","PERL_KEYWORDS","PYTHON_KEYWORDS","RUBY_KEYWORDS","SH_KEYWORDS","C_TYPES","PR_STRING","PR_COMMENT","PR_TYPE","PR_LITERAL","PR_PUNCTUATION","PR_PLAIN","PR_SOURCE","PR_ATTRIB_VALUE","combinePrefixPatterns","regexs","capturedGroupIndex","needToFoldCase","ignoreCase","regex","test","source","replace","escapeCharToCodeUnit","b","v","decodeEscape","charsetPart","cc0","charCodeAt","c1","charAt","parseInt","substring","encodeEscape","charCode","toString","ch","String","fromCharCode","allowAnywhereFoldCaseAndRenumberGroups","parts","match","RegExp","capturedGroups","groupIndex","decimalValue","ch0","charSet","charsetParts","ranges","inverse","out","push","start","end","Math","max","min","sort","consolidatedRanges","lastRange","range","join","caseFoldCharset","cc","rewritten","global","multiline","extractSourceSpans","node","isPreformatted","nocode","chunks","spans","k","walk","text","type","nodeType","className","child","firstChild","nextSibling","nodeName","toLowerCase","nodeValue","sourceCode","appendDecorations","sourceNode","basePos","langHandler","job","pre","langExtension","numberLines","decorations","apply","notWs","createSimpleLexer","shortcutStylePatterns","fallthroughStylePatterns","tokenizer","shortcuts","allPatterns","concat","allRegexs","regexKeys","patternParts","shortcutChars","hasOwnProperty","nPatterns","decorate","pos","tokens","styleCache","ti","nTokens","isEmbedded","token","style","embeddedSource","embeddedSourceStart","embeddedSourceEnd","lang","tokenStart","indexOf","langHandlerForExtension","sourceDecorator","options","hc","regexExcls","regexAny","REGEX_LITERAL","regexLiterals","types","keywords","punctuation","decorateSource","hashComments","cStyleComments","multiLineStrings","startLineNum","lineBreak","document","ownerDocument","li","createElement","appendChild","listItems","breakAfter","lineEndNode","parentNode","parent","copiedListItem","breakLeftOf","limit","copy","rightSide","cloneNode","parentClone","next","sibling","firstLine","tail","index","insertBefore","createTextNode","removeChild","setAttribute","ol","offset","langHandlerRegistry","registerLangHandler","handler","fileExtensions","ext","console","extension","applyDecorator","opt_langExtension","sourceAndSpans","decPos","isIE8OrEarlier","exec","navigator","userAgent","newlineRe","sourceLength","sourceIndex","nSpans","spanIndex","nDecorations","decorationIndex","startPos","startDec","oldDisplay","display","styledText","span","spanEnd","decEnd","textNode","replaceChild","recombineTagsAndDecorations","$prettyPrintOne","sourceCodeHtml","opt_numberLines","nl","container","innerHTML","$prettyPrint","opt_whenDone","opt_root","root","body","doc","byTagName","tn","getElementsByTagName","codeSegments","elements","j","clock","Date","now","langExtensionRe","prettyPrintRe","prettyPrintedRe","preformattedTagNameRe","codeRe","preCodeXmpRe","EMPTY","doWork","endTime","Infinity","cs","attrs","preceder","previousSibling","nt","value","_","name","wrapper","currentStyle","defaultView","whitespace","preformatted","lineNums","nested","tagName","element","undefined","childContentWrapper","getComputedStyle","getPropertyValue","setTimeout","verbatimStrings","tripleQuotedStrings","multilineStrings","PR","PR_ATTRIB_NAME","PR_DECLARATION","PR_KEYWORD","PR_NOCODE","PR_TAG","prettyPrintOne","prettyPrint","define","2","addEventListener","tabs","querySelectorAll","switchTab","event","preventDefault","querySelector","classList","remove","clickedTab","currentTarget","activePaneID","target","getAttribute","add","jQuery","ready","$","on","$button","this","file_frame","wp","media","frames","title","library","button","multiple","attachment","state","get","first","toJSON","siblings","val","url","trigger","open","code-prettify"],"mappings":"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"}